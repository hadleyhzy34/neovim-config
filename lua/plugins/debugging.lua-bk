return {
  "mfussenegger/nvim-dap",
  dependencies = {
    "rcarriga/nvim-dap-ui",
    "theHamsta/nvim-dap-virtual-text",
    "jbyuki/one-small-step-for-vimkind",
    "nvim-neotest/nvim-nio",
  },
  config = function()
    local dap = require("dap")
    local dapui = require("dapui")

    -- Setup nlua adapter for Neovim debugging
    dap.adapters.nlua = function(callback, config)
      callback({ type = "server", host = config.host or "127.0.0.1", port = config.port or 8086 })
    end

    dap.configurations.lua = {
      {
        type = "nlua",
        request = "attach",
        name = "Attach to running Neovim instance",
        host = "127.0.0.1",
        port = 8086,
      },
    }

    -- Setup C++ debugging with LLDB-DAP (from Homebrew LLVM)
    dap.adapters.lldb = {
      id = "lldb",
      type = "executable",
      command = "/opt/homebrew/opt/llvm/bin/lldb-dap",
      args = { "--port", "${port}" },
      options = {
        detached = false,
      },
    }

    -- C++ debugging configurations
    dap.configurations.cpp = {
      {
        name = "Launch file",
        type = "lldb",
        request = "launch",
        program = function()
          return vim.fn.input("Path to executable: ", vim.fn.getcwd() .. "/", "file")
        end,
        cwd = "${workspaceFolder}",
        stopOnEntry = false,
      },
      {
        name = "Launch with args",
        type = "lldb",
        request = "launch",
        program = function()
          return vim.fn.input("Path to executable: ", vim.fn.getcwd() .. "/", "file")
        end,
        args = function()
          local args_str = vim.fn.input("Arguments: ")
          local args = {}
          for arg in string.gmatch(args_str, "%S+") do
            table.insert(args, arg)
          end
          return args
        end,
        cwd = "${workspaceFolder}",
        stopOnEntry = false,
      },
      {
        name = "Attach to process",
        type = "lldb",
        request = "attach",
        pid = function()
          return tonumber(vim.fn.input("Process ID: "))
        end,
        cwd = "${workspaceFolder}",
      },
    }

    -- C configurations are the same as C++
    dap.configurations.c = dap.configurations.cpp

    -- Custom keybinding: Use <leader>dn for step over
    vim.keymap.set("n", "<leader>dn", function() 
      require("dap").step_over() 
    end, { desc = "Step Over" })

    -- Setup dapui with custom layout
    dapui.setup({
      icons = { expanded = "▾", collapsed = "▸" },
      mappings = {
        expand = { "<CR>", "<2-LeftMouse>" },
        open = "o",
        remove = "d",
        edit = "e",
        repl = "r",
      },
      expand_lines = vim.fn.has("nvim-0.7") == 1,
      layouts = {
        {
          elements = {
            { id = "scopes", size = 0.25 },
            { id = "breakpoints", size = 0.15 },
            { id = "stacks", size = 0.15 },
            { id = "watches", size = 0.45 },
          },
          size = 40,
          position = "left",
        },
        {
          elements = {
            "repl",
            "console",
          },
          size = 0.25,
          position = "bottom",
        },
      },
      floating = {
        max_height = nil,
        max_width = nil,
        border = "single",
        mappings = {
          close = { "q", "<Esc>" },
        },
      },
      windows = { indent = 1 },
      render = {
        max_value_lines = 100,
      }
    })

    -- More robust event handling for UI refresh with timer
    local refresh_timer = nil
    
    local function start_refresh_timer()
      if refresh_timer then
        refresh_timer:close()
      end
      
      refresh_timer = vim.loop.new_timer()
      if refresh_timer then
        refresh_timer:start(0, 500, vim.schedule_wrap(function()
          if dap.session() then
            pcall(function()
              if dapui.elements.scopes then
                dapui.elements.scopes.render()
              end
              if dapui.elements.watches then
                dapui.elements.watches.render()
              end
            end)
          else
            -- Stop timer if no session
            if refresh_timer then
              refresh_timer:close()
              refresh_timer = nil
            end
          end
        end))
      end
    end
    
    local function stop_refresh_timer()
      if refresh_timer then
        refresh_timer:close()
        refresh_timer = nil
      end
    end

    local function refresh_ui()
      vim.defer_fn(function()
        pcall(function()
          if dapui.elements.scopes then
            dapui.elements.scopes.render()
          end
          if dapui.elements.watches then
            dapui.elements.watches.render()
          end
          if dapui.elements.stacks then
            dapui.elements.stacks.render()
          end
          if dapui.elements.breakpoints then
            dapui.elements.breakpoints.render()
          end
        end)
      end, 100)
    end

    -- Event listeners with better error handling
    dap.listeners.after['event_initialized']['dapui_config'] = function()
      vim.defer_fn(function()
        pcall(function()
          dapui.open({})
          start_refresh_timer() -- Start periodic refresh
        end)
      end, 100)
    end

    dap.listeners.after['event_stopped']['dapui_config'] = function()
      refresh_ui()
      start_refresh_timer() -- Ensure timer is running
    end

    dap.listeners.after['event_continued']['dapui_config'] = function()
      vim.defer_fn(refresh_ui, 50)
    end

    dap.listeners.before['event_terminated']['dapui_config'] = function()
      stop_refresh_timer()
      pcall(function()
        dapui.close({})
      end)
    end

    dap.listeners.before['event_exited']['dapui_config'] = function()
      stop_refresh_timer()
      pcall(function()
        dapui.close({})
      end)
    end

    -- Add keybindings for DAP UI control
    vim.keymap.set("n", "<leader>du", function()
      dapui.toggle({})
    end, { desc = "Toggle DAP UI" })

    vim.keymap.set("n", "<leader>dw", function()
      local word = vim.fn.expand("<cword>")
      if word and word ~= "" then
        pcall(function()
          dapui.elements.watches.add(word)
        end)
      end
    end, { desc = "Add variable under cursor to watch" })

    vim.keymap.set("n", "<leader>dE", function()
      vim.ui.input({ prompt = "Expression to watch: " }, function(input)
        if input and input ~= "" then
          pcall(function()
            dapui.elements.watches.add(input)
          end)
        end
      end)
    end, { desc = "Add expression to watches" })

    vim.keymap.set("n", "<leader>dA", function()
      refresh_ui()
    end, { desc = "Refresh all DAP UI panels" })

    vim.keymap.set("n", "<leader>dS", function()
      if dap.session() then
        pcall(function()
          if dapui.elements.scopes then
            dapui.elements.scopes.render()
          end
        end)
      end
    end, { desc = "Refresh scopes panel" })
  end,
}

